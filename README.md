## «Airport»

«Airport» - комплекс микросервисов «Airport» для сотрудников аэропорта и пассажиров. Он моделирует ключевые процессы: расписание и выполнение рейсов, бронирования, регистрацию на рейс, контроль безопасности и посадку. Цель — показать, как с помощью микросервисной архитектуры организовать независимые доменные сервисы, балансировку и маршрутизацию трафика, сервис-дискавери и взаимодействие через общий API-шлюз.

## Сервисы и их назначение:

* Eureka Server — реестр сервисов. Хранит список активных инстансов и даёт другим сервисам их обнаруживать по имени.
* API Gateway (порт 2021) — единая входная точка. Маршрутизирует запросы вида /airport-xxx-service/** на нужный сервис по имени через балансировщик (lb://…), делает переписывание пути (RewritePath), позволяет централизовать кросс-срезы (логирование, безоп, лимиты).
* Airport Pilot Service (8081) — домен экипажей/пилотов. Используется операторами расписаний и связанными сервисами для справочной информации.
* Airport Flight Service (8082) — домен рейсов и расписания (статусы рейсов). Нужен пассажирам (статус, время вылета/прилёта) и сотрудникам (планирование гейтов/стоек).
* Airport Bookings Service (8083) — домен бронирований/билетов. Связывает пассажира с рейсом и местом.
* Airport Security Service (8084) — домен контроля безопасности (проверки/допуск). Сотрудники видят статус прохождения досмотра.
* Airport Check-in Service (8085) — регистрация на рейс (выбор места, выдача посадочного талона).
* Airport Boarding Service (8086) — посадка на рейс у гейта (сканирование посадочного, статусы boarding/open/closed).
* MySQL (3306) — транзакционное хранилище общей предметной информации (рейсы, брони, статусы и т.д.).

Все доменные сервисы (pilot/flight/bookings/security/checkin/boarding) подключены к MySQL и регистрируются в Eureka.

### Как сервисы взаимодействуют друг с другом

* Обнаружение (Service Discovery): каждый сервис при старте регистрируется в Eureka и периодически посылает heartbeats. Клиенты обращаются друг к другу не по IP/порту, а по имени (например, AIRPORT-FLIGHT-SERVICE).
* Маршрутизация: внешние клиенты и UI идут только в API Gateway (2021). Шлюз по правилам (routes + predicates + filters) отправляет запрос в нужный сервис по схеме lb://SERVICE-NAME, автоматически выбирая живой инстанс.
* Хранилище: доменные сервисы работают с общей MySQL (инициализируется airportdb.sql). В health-эндпоинтах видно db: UP, значит подключение успешно.
* Синхронные вызовы: демонстрация построена на синхронных HTTP-взаимодействиях через Gateway (внутри — через Discovery + LoadBalancer). При остановке сервиса Gateway даёт 503, при старте — снова 200, что показывает динамику реестра.

### Поток процесса (пример):

* Пассажир делает бронь → Bookings записывает данные в MySQL (может обращаться к Flight за валидацией рейса).
* Пассажир проходит Security → статус допуска сохраняется.
* Пассажир делает Check-in → система подтверждает бронь и выдаёт посадочный.
* На гейте Boarding проверяет посадочный и статус Security, помечает посадку как завершённую.
* Pilot и Flight используются сотрудниками для укомплектования рейса и актуализации статуса.

### Архитектура приложения

* Стиль: классическая микросервисная архитектура.
* Составные блоки:
* API Gateway как фасад/edge-layer (маршрутизация, кросс-срезы).
* Service Discovery (Eureka) для динамической диспетчеризации и масштабирования.
* Доменные микросервисы с чёткими bounded contexts (pilot/flight/bookings/security/checkin/boarding).
* Общее реляционное хранилище (MySQL) для демонстрационных целей.
* Коммуникации: HTTP/REST через Gateway и Discovery-based клиентский лоад-балансер (lb://SERVICE), health-пробы через Actuator.
* Наблюдаемость (опционально): лог-агрегация на уровне Gateway, трейсинг (Zipkin — можно подключить отдельно), метрики Actuator.
* Деплой/операции: контейнеризация Docker, оркестрация Compose (в реале — Kubernetes/ServiceMesh).